# Conceptos de programación para el análisis de datos {#sec-chap-programmingconcepts}

```{python}
#| echo: false
import warnings; warnings.filterwarnings('ignore')
```

**Resumen.**
  Este capítulo muestra a los lectores los conceptos básicos de programación, 
tipos de datos, estructuras de control y funciones en Python y R. Explica cómo 
tratar con objetos, sentencias, expresiones, variables y diferentes tipos de datos, 
y muestra cómo crear y entender estructuras de control sencillas como bucles y condiciones.

**Palabras clave.** fundamentos de programación

**Objetivos:**

- Comprender los objetos y los tipos de datos
 - Escribir estructuras de control
 - Utilizar funciones y métodos


::: {.callout-note icon=false collapse=true}
## Paquetes utilizados en este capítulo

Este capítulo se centra en las propias capacidades de Python y R, por lo que no depende 
de muchos paquetes. Para R, solo se utiliza 'glue' (que permite un buen formato de texto). 
Para Python, solo utilizamos los paquetes 'numpy' y 'pandas' para el soporte de marcos de 
datos. Si es necesario, puedes instalar estos paquetes con el código que se muestra a 
continuación (consulta la Sección [-@sec-installing] para obtener más detalles).

::: {.panel-tabset}
## Código Python
```{python chapter03install-python}
#| eval: false
!pip3 install numpy pandas
```
## Código R
```{r chapter03install-r}
#| eval: false
install.packages("glue")
```
:::
Una vez instalados, tienes que importar (activar) los paquetes en cada sesión

::: {.panel-tabset}
## Código Python
```{python chapter03libraries-python}
import numpy as np
import pandas as pd

```
## Código R
```{r chapter03libraries-r}
library(glue)
```
:::
:::

## Los objetos y tipos de datos {#sec-datatypes}

Después de leer el capítulo [-@sec-chap-fundata] y ver de lo que son capaces 
R y Python, es hora de dar un pequeño paso atrás y aprender más sobre cómo 
realmente funciona todo tras bastidores.

En ambos lenguajes, se escribe un 'script' o 'programa' que contiene los comandos 
para el ordenador. Pero antes de abordar la programación real y a los emocionantes 
análisis, necesitamos entender cómo se pueden representar y almacenar los datos.

Independientemente de si usas R o Python, ambos almacenan tus datos en memoria 
como 'objects' (objetos). Cada uno de estos objetos tiene un nombre, y se crean 
asignando un valor a ese nombre. Por ejemplo, el comando 'x=10' crea un nuevo 
objeto [^1], llamado 'x', y almacena el valor 10 en él. Este objeto se almacena 
ahora en memoria y puede utilizarse en comandos posteriores. Los objetos pueden 
ser simples valores, como el número 10, pero también pueden ser fragmentos de texto, 
datos estructurados (tablas) o resultados de análisis. Llamamos a esta distinción 
el 'type' (tipo) o 'class' (clase) de un objeto.

::: {.callout-note icon=false collapse=true}
## Objetos, punteros y variables.
En programación, se suele distinguir entre el objeto (como el número 10) y la variable 
en la que se almacena (como 'x'). Esta última también se denomina '“pointer”' (puntero). 
Sin embargo, esta distinción no es muy relevante para la mayoría de nuestros propósitos. 
Es más, en estadística, la palabra variable suele referirse a una columna de datos, en 
lugar de al nombre de, por ejemplo, el objeto que contiene todo el conjunto de datos 
(o tabla). Por este motivo, utilizaremos la palabra “objeto” para referirnos tanto al 
objeto o valor real como a su nombre. (Si quieres tener algo más para reflexionar y 
desafiar un poco a tu mente, intenta ver la relación entre la idea de puntero y la 
discusión sobre objetos mutables e inmutables que hay a continuación).
:::

Vamos a crear un objeto al que llamaremos 'a' (un nombre arbitrario, puedes usar el 
que quieras), asignarle el valor 100 y usar la función 'class' (R) o 'type' (Python) 
para comprobar qué tipo de objeto hemos creado (Ejemplo [-@exm-var1]). Como puedes 
ver, R informa del tipo del número como '"numeric"', mientras que Python lo hace como 
'"int"' (abreviatura de *integer* o número entero). Aunque utilizan nombres diferentes, 
ambos lenguajes ofrecen tipos de datos muy similares. La Tabla 3.1 proporciona una 
visión general de algunos tipos de datos comunes.

::: {.callout-note appearance="simple" icon=false}

::: {#exm-var1}
Determinar el tipo de un objeto

::: {.panel-tabset}
## Código Python
```{python var1-python}
a = 100
print(type(a))

```
## Código R
```{r var1-r}
a = 100
print(class(a))
```
:::
:::
:::

|Python| | R| | Descripción|
|-|-|-|-|-|
|
|Nombre | Ejemplo | Nombre | Ejemplo|
|int | `1` | integer | `1L` | Números enteros|
|float | `1.3` | numeric | `1.3` | Números con decimales|
|str | `"Spam", 'ham'` | character | `"Spam", 'ham'` | Datos textuales|
|bool | `True, False` | logical | `TRUE, FALSE` | Valores verdaderos|
: Tipos de datos más usados en Python y R {#tbl-types}

Veamos con más detalle el código del ejemplo [-@exm-var1]. La primera 
línea es una orden para crear el objeto 'a' y almacenar su valor 100; 
y la segunda es ilustrativa y nos dará la clase del objeto creado, 
en este caso '"numeric"' (numérico). Observa que estamos utilizando dos 
funciones nativas de R, 'print' y 'class', e incluyendo 'a' como argumento 
de 'class', y la propia 'class(a)' como argumento de 'print'. En este caso, 
la única diferencia entre R y Python, es que la función Python que necesitamos 
se llama 'type' en lugar de 'class'.

Una vez creada, ya puedes realizar múltiples operaciones con 'a' y otros valores 
o nuevas variables, como se muestra en el Ejemplo [-@exm-var2]. Por ejemplo, podrías 
transformar 'a' multiplicando a por 2, crear una nueva variable 'b' de valor 50 y 
luego crear otro nuevo objeto 'c' con el resultado de 'a + b'.


::: {.callout-note appearance="simple" icon=false}

::: {#exm-var2}
Algunas operaciones sencillas

::: {.panel-tabset}
## Código Python
```{python var2-python}
a = 100
a = a * 2  # es equivalente, pero más corto, a a*=2
b = 50
c = a + b
print(a, b, c)

```
## Código R
```{r var2-r}
a = 100
a = a*2
b = 50
c = a + b
print(a)
print(b)
print(c)
```
:::
:::
:::

### Almacenamiento de valores individuales: Números enteros, números de coma flotante, *booleans*

Cuando trabajamos con números, distinguimos entre *integers* (números enteros, abreviado *int*) 
y números de coma flotante (números con punto decimal, llamados '"numeric"' en R y *“floating point numbers”* 
en inglés). Tanto Python como R determinan automáticamente el tipo de datos al crear un objeto, 
pero difieren en su comportamiento por defecto al almacenar un número que puede representarse como 
un *int*: R lo almacenará como un 'float' (número de coma flotante) de todos modos y habrá 
que forzarlo a hacer lo contrario, mientras que para Python es al revés (Ejemplo [-@exm-var3]). 
También podemos convertir entre tipos más adelante, aunque convertir un 'float' a un 'int' puede 
no ser muy buena idea, ya que truncas los datos.

Entonces, ¿por qué no utilizamos siempre números de coma flotante? En primer lugar, las operaciones
 con *floats* suelen llevar más tiempo que las operaciones con números enteros. En segundo lugar, 
estos números se almacenan como una combinación de un coeficiente y un exponente (en base 2), 
por lo que muchas fracciones decimales solo pueden almacenarse aproximadamente al usarlos. Salvo 
en ámbitos específicos (como las finanzas), estas imprecisiones no suelen tener mucha importancia 
práctica. Pero explica por qué calcular 6*6/10 en Python devuelve 3,6, mientras que 6*0,6 o 6*(6/10) 
devuelve 3,599999999999999996. Por lo tanto, si un valor solo puede ser un número entero (por ejemplo, 
tu edad o el número de casas que tienes), tiene sentido restringir el objeto a que solo pueda ser un 'int'.

También tenemos un tipo de datos que es aún más restringido y solo puede tomar dos valores: verdadero o falso. 
Se llama '"logical"' (lógico) (R) o '"bool"' (Python). Ten en cuenta que los valores booleanos distinguen 
entre mayúsculas y minúsculas: mientras que en R debes escribir todo el valor en mayúsculas (TRUE, FALSE), 
en Python solo escribimos la primera letra en mayúsculas: True, False. Como puedes ver en el Ejemplo [-@exm-var3], 
un objeto de este tipo se comporta exactamente igual que un entero al que solo se le permite ser 0 o 1, y 
se puede convertir fácilmente a un entero.

::: {.callout-note appearance="simple" icon=false}

::: {#exm-var3}
Valores de números enteros, números de coma flotante y boleanos.

::: {.panel-tabset}
## Código Python
```{python var3-python}
d = 20
print(type(d))
# obliga a Python a tratar 20 como un número de coma flotante
d2 = 20.0
print(type(d2))

e = int(20.7)
print(type(e))
print(e)

f = True
print(type(f))
print(int(f))
print(int(False))

```
## Código R
```{r var3-r}
d = 20
print(class(d))
# obliga a R a tratar 20 como un int
d2 = 20L
print(class(d2))

e = as.integer(20.7)
print(class(e))
print(e)

f = TRUE
print(class(f))
print(as.integer(f))
print(as.integer(FALSE))
```
:::
:::
:::

### Almacenaje de texto

Como analista computacional de la comunicación, normalmente trabajarás 
con objetos de texto o cadenas de caracteres. Comúnmente conocidos como 
'"strings"' (cadenas), estos objetos de texto también se denominan 
'"character vector objects"' (objetos vectoriales de caracteres) en R. 
Cada vez que quieras analizar un mensaje de redes sociales, o cualquier 
otro texto, estarás trabajando con este tipo de cadenas.

::: {.callout-note appearance="simple" icon=false}
::: {#exm-var4}
Cadenas y *bytes*.

::: {.panel-tabset}
## Código Python
```{python var4-python}
text1 = "This is a text"
print(f"Type of text1: {type(text1)}")
text2 = "Using 'single' and \"double\" quotes"
text3 = 'Using "single" and "double" quotes'
print(f"Are text2 and text3 equal?{text2==text3}")

```
## Código R
```{r var4-r}
text1 = "This is a text"
glue("Class of text1: {class(text1)}")
text2 = "Using 'single' and \"double\" quotes"
text3 = 'Using \'single\' and "double" quotes'
glue("Are text2 and text3 equal? {text2==text3}")
```
:::

::: {.panel-tabset}
## Código Python
```{python var4b-python}
somebytes = text1.encode("utf-8")
print(type(somebytes))
print(somebytes)

```
## Código R
```{r var4b-r}
somebytes= charToRaw(text1)
print(class(somebytes))
print(somebytes)
```
:::
:::
:::

Como puedes ver en el Ejemplo [-@exm-var4], se puede crear una cadena encerrando el texto 
entre comillas. Puedes utilizar comillas dobles o simples, pero es necesario utilizar la 
misma marca para empezar y terminar la cadena. Esto puede ser útil si deseas utilizar 
comillas dentro de una cadena, ya que puedes utilizar el otro tipo para indicar el principio 
y el final de la cadena. Si necesitas utilizar una comilla simple dentro de una cadena entre 
comillas simples, puedes anular la función (*escape*) de la comilla poniéndole delante una 
barra invertida (`\'`). Ocurre lo mismo para las cadenas entre comillas dobles. Por último, 
para incluir una barra invertida real en un texto, también anulas su función con una barra 
invertida, de modo que se obtiene una barra invertida doble (`\\`).

El ejemplo de Python también muestra un concepto introducido en Python 3.6: la cadena f. 
Se trata de cadenas prefijadas con la letra f que cuentan con un formato específico. Esto 
significa que estas cadenas insertarán automáticamente un valor dónde las llaves indiquen 
que es necesario. Con ello, se puede escribir: 'print(f "The value of i is {i}")' para 
expresar "El valor de i es 5" (dado que *i* es igual a 5). En R, el paquete 'glue' también 
permite utilizar una sintaxis similar a la de 'f: glue("The value of i is \{i\}")'.

Aunque esto se explicará con más detalle en el apartado [-@sec-unicode], conviene explicar 
ahora cómo los ordenadores almacenan el texto en la memoria o en ficheros. No es muy difícil 
imaginar cómo un ordenador maneja internamente los números enteros: aunque el número se nos 
muestre como un número decimal, se puede convertir y almacenar trivialmente como un número 
binario (efectivamente, una serie de ceros y unos). No tenemos que preocuparnos por eso.
 Sin embargo, cuando pensamos en texto, no resulta tan evidente cómo se almacena una cadena 
en una secuencia de ceros y unos, sobre todo teniendo en cuenta la enorme variedad de sistemas 
de escritura utilizados en los distintos idiomas.

De hecho, existen varias formas de almacenar caracteres textuales en forma de bytes, denominadas 
*“encodings”*. El proceso de pasar de *bytes* (números) a caracteres se denomina *decoding* 
(descodificación), y el proceso inverso, *encoding* (codificación). Para trabajar más cómodamente, 
las cadenas (o vectores de caracteres) representan texto ya descodificado. Esto significa que, a 
menudo, cuando lees o escribes datos en un archivo, tienes que especificar la codificación 
(normalmente UTF-8). Sin embargo, tanto Python como R permiten trabajar con los datos sin 
procesar en forma de 'bytes' (Python) o 'raw' (R). Esto puede ser necesario si hay problemas 
de codificación. Puede verse brevemente en la parte inferior del ejemplo [-@exm-var4]. Fíjate en que, 
mientras que R muestra los valores hexadecimales subyacentes de los bytes de los datos 'raw' 
(54 es 'T', 68 es 'h' y así sucesivamente), Python muestra los 'bytes' como caracteres de texto. 
En ambos casos, el tipo de datos subyacente es el mismo: datos sin procesar.

### Combinar múltiples valores: Listas, vectores y compañía

Hasta ahora, nos hemos centrado en los tipos de datos básicos iniciales o *"vector objects"* (objetos vectoriales), 
como se denominan en R. Sin embargo, a menudo queremos agrupar varios de estos objetos. Por ejemplo, 
no queremos crear manualmente miles de objetos llamados tweet0001, tweet0002, ..., tweet9999… Es más 
cómodo tener una lista llamada tuits que los contenga a todos. Existen múltiples nombres para este 
tipo de estructuras de datos combinadas:  *lists* (listas), *vectors* (vectores), *arrays*, series y 
más. La idea es siempre la misma: tomamos varios objetos (ya sean números, cadenas o cualquier otra 
cosa) y creamos un objeto que los combina todos (Ejemplo [-@exm-1darray1]).

::: {.callout-note appearance="simple" icon=false}

::: {#exm-1darray1}
Colección de *arrays* (como los vectores en R o las listas en Python) pueden contener varios valores

::: {.panel-tabset}
## Código Python
```{python 1darray1-python}
scores = [8, 8, 7, 6, 9, 4, 9, 2, 8, 5]
print(type(scores))
countries = ["Netherlands", "Germany", "Spain"]
print(type(countries))

```
## Código R
```{r 1darray1-r}
scores = c(8, 8, 7, 6, 9, 4, 9, 2, 8, 5)
print(class(scores))
countries = c("Netherlands", "Germany", "Spain")
print(class(countries))

```
:::
:::
:::

Como puedes ver, ahora tenemos un nombre ('scores') para referirnos a todas las 
puntuaciones. El objeto de Python del ejemplo [-@exm-1darray1] se llama 'list', 
el objeto de R, 'vector'. Hay muchos más datos combinados de este tipo, con 
propiedades ligeramente diferentes que puede ser importante conocer. En primer 
lugar, si se pueden mezclar diferentes tipos (digamos, enteros y cadenas); 
en segundo lugar, qué ocurre si cambias el *array*. Vamos a discutir ambos 
casos y a mostrar cómo se relacionan con diferentes tipos de conjuntos en 
Python y R. Pero antes, vamos a mostrarte cómo trabajar con ellos.

**Operaciones con vectores y listas.**

Una de las operaciones más básicas que se puede realizar en todo tipo de *arrays* 
unidimensionales es 'indexing' (indexación). Permite localizar cualquier elemento 
o grupo de elementos dentro de un vector utilizando su posición. El primer elemento 
de un vector en R se llama 1, el segundo 2, y así sucesivamente; en Python, empezamos 
a contar con 0. Puedes recuperar un elemento específico de un vector o lista 
simplemente poniendo el índice entre corchetes `[]` (Ejemplo [-@exm-1darray2]).

::: {.callout-note appearance="simple" icon=false}

::: {#exm-1darray2}
Cortar vectores y convertir tipos de datos

::: {.panel-tabset}
## Código Python
```{python 1darray2-python}
scores = ["8", "8", "7", "6", "9", "4", "9", "2", "8", "5"]

print(scores[4])
print([scores[0], scores[9]])
print(scores[0:4])

# Transforma las 4 primeras calificaciones en números
# Fíjate en el uso de una lista de comprensión [.. for ..]
# Se explicará en la sección sobre bucles del libro

scores_new = [int(e) for e in scores[1:4]]
print(type(scores_new))
print(scores_new)

```
## Código R
```{r 1darray2-r}
scores=c("8","8","7","6","9","4","9","2","8","5")

scores[5]
scores[c(1, 10)]
scores[1:4]

# Transforma las 4 primeras calificaciones en números
scores_new = as.numeric(scores[1:4])
class(scores_new)
scores_new
```
:::
:::
:::

En el primer caso, hemos preguntado por la puntuación del 5º alumno ("9"); 
en el segundo, por la del 1º y el 10º ("8" "5"); y, por último, por todos 
los elementos comprendidos entre el 1º y el 4º ("8" "8" "7" "6"). Podemos 
indicar un rango fácilmente utilizando `:`. Después de los dos puntos, 
proporcionamos el 'index' (posición) del último elemento (en R), mientras 
que Python se detiene justo antes de esa posición.[^2] Si queremos pasar 
varios valores concretos en vez de un rango, en R necesitaremos crear un 
vector de estos índices utilizando `c()` (Ejemplo [-@exm-1darray2]). Tómate 
un momento para comparar las diferentes formas de indexación entre Python 
y R en el Ejemplo [-@exm-1darray2].

La indexación es muy útil para acceder a elementos y también para crear 
nuevos objetos a partir de una parte de otro. La última línea de nuestro 
ejemplo muestra cómo crear un nuevo *array* con solo las cuatro primeras 
entradas de 'scores' y almacenarlas todas como números. Para ello, utilizamos 
'slicing' para obtener las cuatro primeras puntuaciones y luego cambiamos 
su clase utilizando la función 'as.numeric' (en R) o convertimos los 
elementos a enteros uno a uno (Python) (Ejemplo [-@exm-1darray2]).


::: {.callout-note appearance="simple" icon=false}

::: {#exm-1darray3}
Algunas operaciones más con *arrays* unidimensionales

::: {.panel-tabset}
## Código Python
```{python 1darray3-python}
# Añadir un nuevo valor a una lista:
scores.append(7)

# Crear una lista nueva en vez de sobreescribirla:
scores4 = scores + [7]

# Eliminar una entrada:
del scores[-10]

# Crear una lista que incluya varios rangos:
list(range(1, 21))
list(range(-5, 6))

# Un rango de decimales: 0, 0.2, 0.4, ... 1.0
# Como los rangos solo trabajan con enteros primero hacemos un rango de 0,2, etc 
#y luego lo dividimos entre 10

my_sequence = [e / 10 for e in range(0, 11, 2)]

```
## Código R
```{r 1darray3-r}
# Añadir un nuevo valor a un vector
scores = c(scores, 7)

# Crear una lista nueva en vez de sobreescribirla:
scores4 = c(scores, 7)

# Eliminar una entrada de un vector:
scores = scores[-10]

# Crear un vector que contenga varios rangos
range1 = 1:20
range2 = -5:5

# Un rango de decimales: 0, 0.2, 0.4, ... 1.0
my_sequence = seq(0,1, by=0.2)
```
:::
:::
:::

Podemos hacer muchas otras cosas, como añadir o eliminar valores, o crear un vector desde cero utilizando 
una función (Ejemplo [-@exm-1darray3]). Por ejemplo, en vez de teclear a mano un gran número de valores, 
podemos desear crear un vector a partir de un operador o una función, sin teclear cada valor. Utilizando 
el operador `:` (R) o las funciones 'seq' (R) o 'range' (Python), podemos crear vectores numéricos 
desde un rango de números.

**¿Podemos mezclar tipos diferentes?**
Hay una razón por la que los tipos de datos básicos (numéricos, caracteres, etc.) que hemos descrito 
anteriormente se denominan "objetos vectoriales" en R. El vector es una estructura muy importante en 
R y consiste en estos objetos. Un vector se puede crear fácilmente con la función 'c' y solo puede 
combinar elementos del mismo tipo (numeric (número real), integer (números enteros), complex 
(números complejos), characters (cadenas de caracteres), logical (datos binarios), raw (almacena bits)). 
Dado que los tipos de datos dentro de un vector corresponden a una sola clase, cuando creamos un vector 
con, por ejemplo, datos numéricos, la función 'class' mostrará '"numeric"' y no '"vector"'.

Si intentamos crear un vector con dos tipos de datos diferentes, R forzará la transformación de algunos 
elementos para que todos pertenezcan a la misma clase. Por ejemplo, si reconstruyes el vector de 
puntuaciones con un alumno nuevo que ha sido calificado con la letra *b* en lugar de un número 
(Ejemplo [-@exm-1darray1b]), tu vector se convertirá en un vector de caracteres. Si lo imprimes, 
verás que los valores aparecen entre '"'.

::: {.callout-note appearance="simple" icon=false}

::: {#exm-1darray1b}
R fuerza que todos los elementos de un vector tengan el mismo tipo de datos 
## Código R
```{r 1darray1b-r}
scores2 = c(8, 8, 7, 6, 9, 4, 9, 2, 8, 5, "b")
print(class(scores2))
print(scores2)
```
:::
:::

A diferencia de un vector, una lista es mucho menos restringida: a las listas no les importa 
si mezclas números y texto. En Python, estas listas son el tipo más común para crear un 
*array* unidimensional. Como pueden contener objetos muy diferentes, ejecutar la función 
'type' sobre ellos no devuelve nada sobre los objetos dentro de la lista, sino que simplemente 
indica que estamos tratando con una lista (Ejemplo [-@exm-1darray1]). De hecho, las listas 
pueden contener incluso otras listas o cualquier otro objeto.

En R también se pueden usar listas, aunque son mucho menos populares que en Python, ya que, 
si todos los objetos son del mismo tipo, los vectores son mejores. Las listas en R se crean 
de forma similar a los vectores, salvo que tenemos que añadir la palabra 'list' antes de 
declarar los valores. Vamos a construir una lista con cuatro tipos diferentes de elementos, 
un objeto numérico, un objeto caracter, una función raíz cuadrada ('sqrt') y un vector 
numérico (Ejemplo [-@exm-1darray4]). Puedes utilizar cualquiera de los elementos de la 
lista mediante indexación. ¡Sí, incluso la función 'sqrt' que has almacenado en la 
lista para obtener la raíz cuadrada de 16!

::: {.callout-note appearance="simple" icon=false}

::: {#exm-1darray4}
Las listas pueden almacenar objetos muy diferentes: desde múltiples tipos de datos hasta funciones

::: {.panel-tabset}
## Código Python
```{python 1darray4-python}
my_list = [33, "Twitter", np.sqrt, [1, 2, 3, 4]]
print(type(my_list))

# Esto se convierte en raíz de (16)
print(my_list[2](16))

```
## Código R
```{r 1darray4-r}
my_list = list(33, "Twitter", sqrt, c(1,2,3,4))
class(my_list)

# Esto se convierte en raíz de (16)
my_list[[3]](16)
```
:::
:::
:::

A los usuarios de Python a menudo les gusta el hecho de que las listas dan mucha flexibilidad, 
ya que aceptan felizmente entradas de tipos muy diferentes. Pero a veces ellos también quieren 
una estructura más estricta como el vector de R. Esto puede ser especialmente interesante 
para cálculos de alto rendimiento, y por lo tanto, tal estructura está disponible en el paquete 
'numpy' (que significa Números en Python): el 'numpy array'. Hablaremos de ello con más detalle 
cuando tratemos los marcos de datos en el capítulo [-@sec-chap-filetodata].

::: {.callout-note icon=false collapse=true}
## Referencias a objetos y objetos mutables.


Una sutil diferencia entre Python y R es cómo tratan la copia de objetos. Supongamos que definimos 
$x$, que contiene los números $1,2,3$ (`x=[1,2,3]` en Python o `x=c(1,2,3)` en R) y luego definimos 
un objeto $y$ igual a $x$ (`y=x`). En R, ambos objetos se mantienen separados, por lo que cambiar 
$x$ no afecta a $y$, que es probablemente lo que esperas. En Python, sin embargo, ahora tenemos dos 
variables (nombres) que apuntan o hacen referencia al mismo objeto, y si cambiamos $x$ también 
cambiamos $y$ y viceversa, lo que puede pillarnos por sorpresa. Si lo que quieres es copiar un 
objeto en Python, es mejor ejecutar 'x.copy()'. Presta atención al Ejemplo [-@exm-mutable] para ver ejemplo.

Ten en cuenta que esto solo es importante para los objetos mutables, es decir, los objetos que se 
pueden cambiar. Por ejemplo, las listas en Python y R y los vectores en R son mutables porque puedes 
reemplazar o añadir elementos. Las cadenas y los números, por otro lado, son inmutables: no puedes 
cambiar un número o una cadena, una sentencia como 'x=x*2' crea un nuevo objeto que contiene el valor 
de 'x*2' y lo almacena bajo el nombre 'x'.
:::

::: {.callout-note appearance="simple" icon=false}

::: {#exm-mutable}
El (inesperado) comportamiento de los objetos mutables

::: {.panel-tabset}
## Código Python
```{python mutable-python}
x = [1, 2, 3]
y = x
y[0] = 99
print(x)

```
## Código R
```{r mutable-r}
x = c(1,2,3)
y = x
y[1] = 99
print(x)
```
:::
:::
:::

**Sets y tuplas.**
El vector (R) y la lista (Python) son las colecciones más utilizadas para 
almacenar múltiples objetos. Pero en Python hay otros dos tipos de colecciones 
que es probable que encuentres. En primer lugar, las 'tuples' (tuplas) son muy 
similares a las listas, pero no se pueden modificar después de crearlas (son 
inmutables). Puedes crear una tupla sustituyendo los corchetes por paréntesis 
normales: 'x=(1,2,3)'.

En segundo lugar, en Python existe un tipo de objeto llamado 'set' (conjunto). 
Un *set* es una colección mutable de elementos únicos (no se puede repetir un 
valor) sin orden. Como no está bien ordenado, no puedes ejecutar ninguna operación 
de indexación o corte sobre él. Aunque R no tiene un tipo de *set* equivalente, 
sí tiene funciones para las diversas operaciones de *set*, la más útil de las 
cuales es probablemente la función 'unique', que elimina todos los valores 
duplicados en un vector. El ejemplo [-@exm-sets] muestra una serie de operaciones 
de *set* en Python y R que pueden ser muy útiles, por ejemplo, para encontrar 
todos los elementos que aparecen en dos listas.

::: {.callout-note appearance="simple" icon=false}

::: {#exm-sets}
*Sets*

::: {.panel-tabset}
## Código Python
```{python sets-python}
a = {3, 4, 5}
my_list = [3, 2, 3, 2, 1]
b = set(my_list)
print(f"Set a: {a}; b: {b}")
print(f"intersect:  a & b = {a & b}")
print(f"union:      a | b = {a | b}")
print(f"difference: a - b = {a - b}")

```
## Código R
```{r sets-r}
a = c(3, 4, 5)
my_vector = c(3, 2, 3, 2, 1)
b = unique(my_vector)
print(b)
print(intersect(a,b))
print(union(a,b))
print(setdiff(a,b))
```
:::
:::
:::

### Diccionarios

Los 'dictionaries' (diccionarios) de Python son un tipo de datos 
muy potentes y versátiles. Los diccionarios contienen colecciones 
no ordenadas [^3] y mutables de objetos que contienen cierta información 
de otro objeto. Python genera este tipo de datos en forma de pares 
'{key : value}' para poder mapear cualquier objeto por su *key* 
(clave) y no por su posición relativa en la colección. A diferencia 
de una lista, en la que se indexa con un entero que denota la posición 
en la lista, en un diccionario se puede indexar por la clave. Este es 
el caso que se muestra en el Ejemplo [-@exm-dict], en el que queremos 
obtener los valores del objeto "'positive'" en el diccionario 'sentiments' 
y del objeto "'A'" en el diccionario 'grades'. Vas a encontrar diccionarios 
muy útiles en tu camino como científico computacional o profesional, ya 
que son formas flexibles de almacenar y recuperar información estructurada. 
Podemos crearlos utilizando las llaves '{}' e incluyendo cada par clave-valor 
como un elemento de la colección (Ejemplo [-@exm-dict]).

En R, lo más parecido a un diccionario de Python es utilizar listas con 
elementos nombrados. Esto permite asignar y recuperar valores por clave, 
sin embargo, la clave está restringida a nombres, mientras que en Python 
la mayoría de los objetos pueden usarse como claves. Puedes crear una lista 
con nombre con 'd = list(name=value)' y acceder a los elementos individuales 
con 'd$name' o 'd[["name"]]'.

::: {.callout-note appearance="simple" icon=false}

::: {#exm-dict}
Pares de clave-valor en diccionarios de Python y listas con nombre en R

::: {.panel-tabset}
## Código Python
```{python dict-python}
sentiments = {"positive": 1, "neutral": 0, "negative": -1}
print(type(sentiments))
print("Sentiment for positive:", sentiments["positive"])

grades = {}
grades["A"] = 4
grades["B"] = 3
grades["C"] = 2
grades["D"] = 1

print(f"Grade for A: {grades['A']}")
print(grades)

```
## Código R
```{r dict-r}
sentiments = list(positive=1, neutral=0, 
                  negative=-1)
print(class(sentiments))
print(glue("Sentiment for positive: ",
           sentiments$positive))

grades =  list()
grades$A = 4
grades$B = 3
grades$C = 2
grades$D = 1
# Nota: grades[["A"]] es equivalente a grades$A
print(glue("Grade for A: {grades[['A']]}"))
print(glue("Grade for A: {grades$A}"))
print(grades)
```
:::
:::
:::
Una buena analogía de un diccionario es una guía telefónica (imagínate 
una de papel, aunque suele valer también para las guías telefónicas digitales): 
los nombres son las claves, y los números de teléfono asociados, los valores. 
Si conoces el nombre de alguien (la clave), es muy fácil buscar los valores 
correspondientes: incluso en una guía telefónica de miles de páginas, tardas 
unos 10 o 20 segundos en buscar el nombre (la clave). Pero, si solo conoces 
el número de teléfono de alguien (el valor) y quieres buscar el nombre, no es 
eficiente: tienes que leer toda la guía telefónica hasta encontrar el número.

Igual que los elementos de una lista pueden ser de cualquier tipo y se pueden 
tener listas de listas, también se pueden anidar diccionarios para obtener 
diccionarios de diccionarios. Piensa en nuestro ejemplo de la guía telefónica: 
en lugar de almacenar solo un número de teléfono como valor, podríamos almacenar 
otro diccionario con las claves "teléfono de oficina", "teléfono móvil", etc. 
Esto se hace muy a menudo, y encontrarás muchos ejemplos de este tipo de estructuras 
de datos. Sin embargo, hay una restricción: las claves de un diccionario (a diferencia 
de los valores) no pueden ser mutables. Después de todo, imagina que pudieras 
usar una lista como clave en un diccionario, y si al mismo tiempo, algún otro 
puntero a esa misma lista pudiera cambiarla, esto solo produciría confusión.

### De una a más dimensiones: Matrices y *arrays* n-dimensionales

Las matrices son conjuntos de datos rectangulares bidimensionales que 
incluyen valores en filas y columnas. Éste es el tipo de datos con el 
que tendrás que tratar en muchos de los análisis que se muestran en este 
libro, como los relacionados con el aprendizaje automático. A menudo, 
podemos generalizar a dimensiones superiores.

::: {.callout-note appearance="simple" icon=false}

::: {#exm-2darray}
Trabajar con *arrays* bi- o n- dimensionales

::: {.panel-tabset}
## Código Python
```{python 2darray-python}
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(matrix)

array2d = np.array(matrix)
print(array2d)

```
## Código R
```{r 2darray-r}
my_matrix = matrix(c(0, 0, 1, 1, 0, 1), 
    nrow = 2, ncol = 3, byrow = TRUE)
print(dim(my_matrix))
print(my_matrix)

my_matrix2 = matrix(c(0, 0, 1, 1, 0, 1), 
    nrow = 2, ncol = 3, byrow = FALSE)
print(my_matrix2)
```
:::
:::
:::

En Python, la representación más sencilla es simplemente construir una lista 
de listas. De hecho, esto es lo que se hace a menudo, pero tiene la desventaja 
de que no hay formas fáciles de obtener, por ejemplo, las dimensiones (la forma) 
de la tabla, o de imprimirla en un formato ordenado. Para obtener todo eso, 
se puede transformar la lista de listas en un 'array', una estructura de datos 
proporcionada por el paquete 'numpy' (para más detalles, véase el capítulo [-@sec-chap-filetodata]).

Para crear una matriz en R, hay que utilizar la función 'matrix' y crear un vector 
de valores indicando cuántas filas y columnas habrá en él. También tenemos que 
decirle a R si el orden de los valores está determinado por la fila o no. En el 
Ejemplo [-@exm-2darray], creamos dos matrices en las que variamos el argumento 
'byrow' para que sea 'TRUE' y 'FALSE', respectivamente, para ilustrar cómo cambia 
los valores de la matriz, incluso cuando la forma ($2 \times3$) permanece idéntica. 
Como puedes imaginar, podemos operar con matrices, como por ejemplo sumar dos de ellas.

### Simplifiquemos: Marcos de datos

Hasta ahora, hemos hablado de las colecciones generales que se encuentran integradas en la mayoría de 
los lenguajes de programación, como la lista y el *array*. Sin embargo, en la ciencia de datos y la 
estadística es muy probable que nos encontremos con un tipo de colección específico que aún no hemos 
tratado: el *data frame* (marco de datos). Los marcos de datos se tratan en detalle en el 
Capítulo [-@sec-chap-filetodata], pero para completar el capítulo también los introduciremos brevemente aquí.

Los marcos de datos son estructuras de datos fáciles de usar que se parecen mucho a las que se encuentran 
en SPSS, Stata o Excel. Te van a servir de ayuda en una amplia gama de análisis estadísticos. Un marco de 
datos es un objeto de datos tabular que incluye filas (normalmente las instancias o casos) y columnas 
(las variables). En un marco de datos de tres columnas, la primera variable puede ser numérica, la segunda 
de caracteres y la tercera lógica, pero lo importante es que cada variable sea un vector y que todos estos 
vectores tengan la misma longitud. Creamos marcos de datos desde cero utilizando la función 'data.frame()'. 
Vamos a generar un marco de datos sencillo de tres instancias (cada caso es un autor de este libro) y tres 
variables de tipo numérico (edad), carácter (país en el que obtuvieron su máster) y lógico (vivir en el 
extranjero, si viven actualmente fuera del país en el que nacieron) (Ejemplo [-@exm-dataframe1]). Observa 
que la etiqueta de las variables está en la parte superior de cada columna y que se crea una numeración 
automática para indexar las filas.

::: {.callout-note appearance="simple" icon=false}

::: {#exm-dataframe1}
Creación de un marco de datos simple

::: {.panel-tabset}
## Código Python
```{python dataframe1-python}
authors = pd.DataFrame(
    {
        "age": [38, 36, 39],
        "countries": ["Netherlands", "Germany", "Spain"],
        "living_abroad": [False, True, True],
    }
)
print(authors)

```
## Código R
```{r dataframe1-r}
authors = data.frame(age = c(38, 36, 39), 
  countries = c("Netherlands","Germany","Spain"), 
  living_abroad= c(FALSE, TRUE, TRUE))
print(authors)
```
:::
:::
:::

## Estructuras de control simples: Bucles y condiciones {#sec-controlstructures}

::: {.callout-note icon=false collapse=true}
## Estructuras de control en Python y R.

Esta sección y la siguiente explican el funcionamiento de estructuras de control como 
bucles, condiciones y funciones. Éstas existen (y son muy útiles) tanto en Python como 
en R. En R, sin embargo, no son muy necesarias, ya que la mayoría de las funciones pueden 
trabajar en columnas enteras de una sola vez, mientras que en Python a menudo se realizan 
las operaciones en cada fila de una columna y a veces ni si quiera se utilizan marcos de 
datos. Por lo tanto, si solo tienes interés en aprender a utilizar R, puedes saltarte el 
resto de este capítulo por ahora y volver más tarde cuando estés preparado para aprender 
más. Si estás aprendiendo Python, te recomendamos encarecidamente que continúes con este 
capítulo, ya que las estructuras de control se utilizan en muchos de los ejemplos del libro.

:::

Tener una comprensión clara de los objetos y los tipos de datos es crucial para comprender 
cómo funcionan los lenguajes orientados a objetos como R y Python, pero, por ahora, necesitamos 
adquirir cierta alfabetización a la hora de escribir código e interactuar con el ordenador y 
los objetos que hemos creado. Aprender un lenguaje de programación es como aprender cualquier 
idioma nuevo: imagina que quieres hablar italiano o que quieres aprender a tocar el piano. 
Lo primero será aprender algunas palabras o notas musicales, y familiarizarte con los ejemplos 
y estructuras básicas, tal y como hicimos en el capítulo [-@sec-chap-fundata]. En el caso del 
italiano o del piano, habría que aprender algo de gramática: cómo formar frases, cómo tocar 
algunos acordes o, más en general, cómo reproducir patrones. Y así es exactamente como vamos 
a adquirir la alfabetización computacional: aprendiendo las reglas para que el ordenador 
haga exactamente lo que quieres.

Recuerda que puedes interactuar con R y Python directamente en sus consolas tecleando cualquier 
comando. Sin embargo, cuando empieces a utilizar y combinar varios de estos comandos, tendrás 
que poner todas estas instrucciones en un *script* que luego podrás ejecutar parcial o totalmente. 
Recuerda la Sección [-@sec-installing], donde mostramos cómo IDEs (como RStudio y Pycharm) ofrecen 
tanto una consola para teclear directamente comandos individuales como una ventana más grande para 
escribir *scripts* más largos.

Tanto R como Python son lenguajes interpretados (a diferencia de los lenguajes compilados), lo que 
significa que interactuar con ellos es muy sencillo: proporcionas a tu ordenador algunas sentencias 
(directamente o a partir de un *script*), y tu ordenador reacciona. Una secuencia de instrucciones 
es lo que llamamos un programa informático. Cuando creamos objetos escribiendo, por ejemplo, 'a = 100', 
nos estamos enfrentando a una sentencia muy básica, la sentencia de asignación. Pero, por supuesto, 
las sentencias pueden ser más complejas.

En concreto, es posible que queramos dar más instrucciones sobre cómo y cuándo deben ejecutarse las 
sentencias. Quizá queramos repetir el cálculo de un valor para cada elemento de una lista, o quizá 
queramos hacerlo solo si se cumple alguna condición.

Tanto R como Python tienen este tipo de *loops* (bucles) y *conditional statements* (sentencias condicionales), 
que harán tu aventura por la codificación mucho más fácil y con resultados más sofisticados (ya que podrás 
controlar la forma en que se ejecutan tus sentencias). Controlando el flujo de instrucciones puedes hacer 
frente a muchos retos de la programación informática, como iterar sobre casos ilimitados o ejecutar parte 
de tu código en función de nuevas entradas.

En tu *script*, normalmente indicas los bucles y condiciones visualmente usando la sangría. Los espacios 
lógicos vacíos (dos en R y cuatro en Python) representan bloques y sub-bloques en la estructura del 
código. Como verás en la siguiente sección, en R, el uso de la sangría es opcional, y las llaves 
indicarán el principio (`{`) y el final (`}`) de un bloque de código; mientras que, en Python, 
la sangría es obligatoria e indica a tu intérprete dónde empieza y termina el bloque.

### Bucles {#sec-loops}

Los bucles pueden utilizarse para repetir un bloque de sentencias. Se ejecutan una vez, indefinidamente 
o hasta que se alcanza una determinada condición. Esto significa que puedes operar sobre un conjunto de 
objetos tantas veces como quieras con solo dar una instrucción. Los tipos más comunes de bucles son *for*, 
*while* y *repeat* (*do-while*), pero nosotros nos ocuparemos sobre todo de los llamados bucles *for*. 
Imagina que tienes una lista de titulares como objeto y quieres un *script* sencillo para imprimir la 
longitud de cada mensaje. Por supuesto, puedes ir titular por titular utilizando la indexación, pero te 
aburrirás o no tendrás tiempo suficiente si cuentas con miles de casos. Por lo tanto, la idea es operar 
un bucle en la lista para que pueda obtener todos los resultados, desde el primero hasta el último elemento, 
con una sola instrucción. La sintaxis del bucle *for* es:

::: {.panel-tabset}
## Código Python
```{python forsyntax-python}
#| eval: false
for val in sequence:
    statement1
    statement2
    statement3

```
## Código R
```{r forsyntax-r}
#| eval: false
for (val in sequence) {
    statement1 
    statement2 
    statement3
}
```
:::

Como ilustra el Ejemplo [-@exm-forloop], cada vez que necesites repetir 
la misma acción una y otra vez, por ejemplo imprimir cada elemento de una 
lista, puedes simplificarlo iterando o haciendo un bucle sobre los elementos, 
en este caso, de la lista. Observa que obtienes los mismos resultados, 
pero con el bucle puedes automatizar tu operación escribiendo pocas líneas 
de código. Como insistiremos en este libro, una buena práctica en codificación 
es ser eficientes y armónicos en la cantidad de código que escribimos, lo cual 
es otra justificación para usar bucles.

::: {.callout-note appearance="simple" icon=false}

::: {#exm-forloop}
Los bucles *for* permiten repetir operaciones.

::: {.panel-tabset}
## Código Python
```{python forloop-python}
headlines = [
    "US condemns terrorist attacks",
    "New elections forces UK to go back to the UE",
    "Venezuelan president is dismissed",
]
# Cada elemento se cuenta manualmente
print("manual results:")
print(len(headlines[0]))
print(len(headlines[1]))
print(len(headlines[2]))
# y en el segundo se aplica un bucle for
print("for-loop results:")
for x in headlines:
    print(len(x))

```
## Código R
```{r forloop-r}
headlines = list("US condemns terrorist attacks", 
  "New elections forces UK to go back to the UE",
  "Venezuelan president is dismissed")
# Cada elemento se cuenta manualmente
print("manual results:  ")
print(nchar(headlines[1]))
print(nchar(headlines[2]))
print(nchar(headlines[3]))
# Se aplica un bucle for
print("for-loop results:")
for (x in headlines){
  print(nchar(x))
}
```
:::
:::
:::

::: {.callout-note icon=false collapse=true}
## ¡No te repitas!

Puede que estés acostumbrado a copiar y pegar la sintaxis, cambiándola 
ligeramente, cuando trabajas con algún programa estadístico: ejecutas 
un análisis y luego repites el mismo análisis con diferentes conjuntos 
de datos o diferentes especificaciones. Pero esto es propenso a errores 
y difícil de mantener, ya que implica mucho trabajo extra si se quiere 
cambiar algo. En la mayoría de casos en los que tienes que utilizar una 
y otra vez el mismo código, sería mejor que utilizaras un bucle *for*.

:::

Otra forma de iterar en Python es usando comprensiones de lista (no disponibles 
nativamente en R), que son una forma elegante de crear listas de elementos 
automáticamente incluso con cláusulas condicionales. Esta es la sintaxis:

```
newlist  = [expression for item in list if conditional]
```

En el Ejemplo [-@exm-listcomprehensions] proporcionamos un ejemplo sencillo 
(sin ninguna cláusula condicional) que crea una lista con el número de caracteres 
de cada titular. Como ilustra este ejemplo, las comprensiones de lista permiten, 
esencialmente, escribir todo un bucle *for* en una línea. Por ello, son muy 
populares en Python.

::: {.callout-note appearance="simple" icon=false}

::: {#exm-listcomprehensions}
Las comprensiones de listas son muy populares en Python 
## Código Python
```{python listcomprehensions-python}
len_headlines = [len(x) for x in headlines]
print(len_headlines)

# Nota: la “lista de comprensión” de arriba es un equivalente más 
# simple al código que hay continuación:
len_headlines = []
for x in headlines:
    len_headlines.append(len(x))
print(len_headlines)

```
:::
:::

### Sentencias condicionales

Las sentencias condicionales te permitirán controlar el flujo y el orden 
de los comandos que le das al ordenador. Esto significa que puedes decirle 
a la computadora que haga esto o aquello, dependiendo de una circunstancia 
dada. Estas sentencias utilizan operadores lógicos para probar si tu condición 
se cumple (*True*) o no (*False*) y ejecutar una instrucción en consecuencia. 
Tanto en R como en Python, utilizamos las cláusulas *if*, *else if* (*elif* 
en Python), y else para escribir la sintaxis de las sentencias condicionales. 
Empecemos mostrándote la estructura básica de la sentencia condicional:

::: {.panel-tabset}
## Código Python
```{python ifsyntax-python}
#| eval: false
if condition:
    statement1
elif other_condition:
    statement2
else:
    statement3

```
## Código R
```{r ifsyntax-r}
#| eval: false
if (condition) {
    statement1
} else if (other_condition) {
    statement2
} else {
    statement3
}
```
:::

Supongamos que queremos imprimir los titulares del Ejemplo [-@exm-forloop] solo 
si el texto tiene menos de 40 caracteres. Para ello, podemos incluir la sentencia 
condicional en el bucle, ejecutando el cuerpo solo si se cumple la condición 
(Ejemplo [-@exm-if1])

::: {.callout-note appearance="simple" icon=false}

::: {#exm-if1}
Una estructura de control condicional simple

::: {.panel-tabset}
## Código Python
```{python if1-python}
for x in headlines:
    if len(x) < 40:
        print(x)

```
## Código R
```{r if1-r}
for (x in headlines){
  if (nchar(x)<40) {
    print(x)}
  }

```
:::
:::
:::

También podríamos complicarlo un poco más: primero comprobar si la longitud es inferior a 40, 
luego comprobar si es exactamente 44 ('elif' / 'else if') y, por último, especificar qué hacer 
si no se cumple ninguna de las condiciones ('else').

En el Ejemplo ], imprimiremos el titular si es inferior a 40 caracteres, imprimiremos la 
cadena *“What a coincidence!”* ("¡Qué casualidad!") si tiene exactamente 44 caracteres, e 
imprimiremos *“Too Low”* ("Demasiado bajo") en todos los demás casos. Observa que hemos 
incluido la cláusula 'elif' en la estructura (en R se anota 'else if'). 'elif' es una combinación 
de 'else' e 'if': si no se cumple la condición anterior, se comprueba esta condición y se 
ejecuta el bloque de código (o bloque 'else') correspondiente. Esto evita tener que anidar el 
segundo 'if' dentro del 'else', mientras que el razonamiento detrás de las sentencias de flujo 
de control sigue siendo el mismo.

::: {.callout-note appearance="simple" icon=false}

::: {#exm-if2}
Una estructura de control condicional más compleja

::: {.panel-tabset}
## Código Python
```{python if2-python}
for x in headlines:
    if len(x) < 30:
        print(x)
    elif len(x) == 44:
        print("What a coincidence!")
    else:
        print("Too low")

```
## Código R
```{r if2-r}
for (x in headlines) {
  if (nchar(x)<30) {
    print(x)
  } else if (nchar(x)==44) {
      print("What a coincidence!")
  } else {
      print("Too low")
  }
}

```
:::
:::
:::

## Funciones y métodos {#sec-functions}

Las funciones (*sentence*, en inglés) y  los métodos son conceptos fundamentales 
a la hora de escribir código en programación orientada a objetos. Ambos son 
objetos que utilizamos para almacenar un conjunto de sentencias y operaciones 
que podemos utilizar más adelante sin tener que volver a escribir toda la sintaxis. 
Esto hace que nuestro código sea más sencillo y potente.

Ya hemos utilizado algunas funciones nativas, como 'length' y 'class' (R) y 'len' 
y 'type' (Python) para obtener la longitud de un objeto y la clase a la que pertenece. 
Pero, como aprenderás en este capítulo, también puedes escribir tus propias funciones. 
En esencia, una función toma algo de entrada (los argumentos suministrados entre paréntesis) 
y devuelve algo de salida. Los métodos son un concepto muy similar: la diferencia entre 
ellos es que las funciones se definen independientemente del objeto, mientras que los 
métodos se crean basándose en una clase, lo que significa que están asociados a un objeto. 
Por ejemplo, en Python, cada cadena tiene asociado un método 'lower', de forma que al escribir 
''HELLO'.lower()' devolverá *“hello”*. En R, en cambio, se utiliza una función, 'tolower('HELLO')'. 
Nosotros no vamos a profundizar en por qué algunas cosas se implementan como método y otras 
como función, ya que muchas veces son elecciones arbitrarias por parte de los desarrolladores. 
Si te interesara comprenderlas completamente, deberías sumergirte en el concepto de clases, 
lo cual no vamos a tratar en este libro pero es posible de aprender a través de otras fuentes.

::: {.callout-note icon=false collapse=true}
## Completado con tabulación (*Tab completion*).
Dado que los métodos están asociados a un objeto, hay un truco 
muy útil para saber qué métodos (y otras propiedades de un objeto) 
existen: Completar con *TAB*. En Jupyter, solo tienes que escribir 
el nombre de un objeto seguido de un punto (por ejemplo, *a.<TAB>* 
en caso de que tengas un objeto llamado *a*) y pulsar la tecla TAB. 
Esto abrirá un menú desplegable del que puedes elegir.

:::

Vamos a ver cómo crear funciones sencillas en R y Python, para que entiendas 
mejor cómo funcionan. Imagina que quieres crear dos funciones: una que calcule 
el 60% de cualquier número dado y otra que calcule este porcentaje solo si el 
argumento dado está por encima del umbral de 5. La estructura general de una 
función en R y Python es:

::: {.panel-tabset}
## Código Python
```{python functionsyntax-python}
#| eval: false
def f(par1, par2=0):
    statements
    return return_value

result = f(arg1, arg2)
result = f(par1=arg1, par2=arg2)
result = f(arg1, par2=arg2)
result = f(arg1)

```
## Código R
```{r functionsyntax-r}
#| eval: false
f = function(par1, par2=0) {
   statements 
   return_value
}
result = f(arg1, arg2)
result = f(par1=arg1, par2=arg2)
result = f(arg1, par2=arg2)
result = f(arg1)
```
:::

En ambos casos, esto define una función llamada 'f', con dos argumentos, 'arg_1' 
y 'arg_2'. Cuando se ejecuta la función, se especifican los valores de estos parámetros 
(los argumentos) entre paréntesis después del nombre de la función. A continuación, 
puedes almacenar el resultado de la función como un objeto de forma normal.

Como puedes ver en la sintaxis anterior, tienes algunas opciones a la hora de especificar 
los argumentos. En primer lugar, puedes especificarlos por nombre o por posición. 
Si incluyes el nombre '(f(param1=arg1))' vinculas explícitamente ese argumento a ese parámetro. 
Si no incluyes el nombre '(f(arg1, arg2))' el primer argumento coincide con el primer parámetro 
y así sucesivamente. Ten en cuenta que puedes combinar estas opciones, especificando algunos 
parámetros por su nombre y otros por su posición.

En segundo lugar, algunas funciones tienen parámetros opcionales, para los que proporcionan 
un valor por defecto. En este caso, 'par2' es opcional, con valor por defecto '0'. Esto 
significa que, si no se especifica el parámetro, se utilizará el valor por defecto. 
Normalmente, los parámetros obligatorios son los objetos principales que utiliza la 
función para realizar su trabajo, mientras que los parámetros opcionales son opciones o 
ajustes adicionales. Se recomienda generalmente especificar estas opciones por su nombre 
cuando se ejecuta una función, ya que esto aumenta la legibilidad del código. La conveniencia 
de especificar los argumentos obligatorios por su nombre depende de la función: si es obvio 
lo que hace el argumento, puedes especificarlo por su posición, pero en caso de duda suele 
ser mejor especificarlos por su nombre.

Por último, ten en cuenta que en Python indicas explícitamente el valor resultante de la 
función con 'return value'. En R, el valor de la última expresión se devuelve automáticamente, 
aunque también puedes ejecutar 'return(valor)'.

El ejemplo [-@exm-functions] muestra cómo escribir nuestra función y cómo utilizarla.

::: {.callout-note appearance="simple" icon=false}

::: {#exm-functions}
Escribir funciones

::: {.panel-tabset}
## Código Python
```{python functions-python}
# La primera función solo calcula el 60% del valor
def perc_60(x):
    return x * 0.6

print(perc_60(10))
print(perc_60(4))

# La segunda función solo calcula el 60% si el valor 
# es mayor que 5
def perc_60_cond(x):
    if x > 5:
        return x * 0.6
    else:
        return x

print(perc_60_cond(10))
print(perc_60_cond(4))

```
## Código R
```{r functions-r}
# La primera función solo calcula el 60% del valor
perc_60 = function(x) x*0.6

print(perc_60(10))
print(perc_60(4))

# La segunda función solo calcula el 60% si el valor 
# es mayor que 5
perc_60_cond = function(x) {
  if (x>5) {
    return(x*0.6)
  } else {
    return(x)
  }
}
print(perc_60_cond(10))
print(perc_60_cond(4))
```
:::
:::
:::

Sin embargo, la potencia de las funciones reside en los escenarios en 
los que se utilizan repetidamente. Imagina que tienes una lista de 5 
(¡o 5 millones!) puntuaciones y deseas aplicar la función perc_60_cond a 
todas las puntuaciones a la vez utilizando un bucle. Esto solo añadirá 
dos líneas de código adicionales (Ejemplo [-@exm-functions2]).

::: {.callout-note appearance="simple" icon=false}

::: {#exm-functions2}
Las funciones son especialmente útiles cuando se utilizan repetidamente

::: {.panel-tabset}
## Código Python
```{python functions2-python}
# La función se ejecuta en un bucle for
scores = [3, 4, 5, 7]
for x in scores:
    print(perc_60_cond(x))

```
## Código R
```{r functions2-r}
# La función se ejecuta en un bucle for
scores = list(3,4,5,6,7)
for (x in scores) {
  print(perc_60_cond(x))
}
```
:::
:::
:::

::: {.callout-note icon=false collapse=true}

Un tipo específico de función en Python con el que te puedes encontrar (como verás en la Sección [-@sec-crawling]) 
es el 'generator' (generador). Piensa en una función que devuelve una lista de múltiples valores. A menudo, no 
necesitas todos los valores a la vez: puede que, cada vez que se ejecute, solo necesites el siguiente valor. 
Esto es importante cuando calcular toda la lista llevaría mucho tiempo o mucha memoria. Esto permite empezar 
a procesar inmediatamente el primer valor antes de que llegue el siguiente, o trabajar con datos tan grandes 
que no caben todos en la memoria al mismo tiempo. Sabemos que es un generador por la palabra clave 'yield' en lugar 
'return' (Ejemplo [-@exm-generators])

:::

::: {.callout-note appearance="simple" icon=false}

::: {#exm-generators}

Los generadores se comportan como listas en el sentido de que se puede iterar (bucle) sobre ellos, 
pero cada elemento solo se calcula cuando es necesario. Por lo tanto, no tienen longitud. 

## Código Python
```{python generators-python}
mylist = [35, 2, 464, 4]

def square1(somelist):
    listofsquares = []
    for i in somelist:
        listofsquares.append(i**2)
    return listofsquares

mysquares = square1(mylist)
print(
    f"""En forma de lista:
type: {type(mysquares)}
representation: {mysquares}
entries: {[x for x in mysquares]}
second pass: {[x for x in mysquares]}
length: {len(mysquares)}"""
)

def square2(somelist):
    for i in somelist:
        yield i**2

mysquares = square2(mylist)
print(
    f"""En forma de generador:
type: {type(mysquares)}
representation: {mysquares}
entries: {[x for x in mysquares]}
second pass: {[x for x in mysquares]}"""
)
# Esto causa un error (los generadores no tienen longitud)
# print(f"length: {len(mysquares)}")


```
:::
:::

Hasta ahora, te hemos ayudado a dar tus primeros pasos como programador, 
pero no debes olvidar que hay muchísimas cosas interesantes que no trataremos 
en este libro. Puedes encontrar fácilmente bibliografía, documentación online 
e incluso maravillosos tutoriales en Youtube para seguir aprendiendo. Te 
recomendamos los libros de @crawley2012r y @vanderplas2016python para tener más 
conocimientos sobre R y Python, respectivamente. En el próximo capítulo, 
nos adentraremos en el mundo del código para aprender cómo y por qué debes 
reutilizar el código existente, qué hacer si te atascas durante tu viaje por la 
programación y cuáles son las mejores prácticas a la hora de codificar. 


[^1]: Tanto en R como en Python, el signo igual ('=') se puede utilizar para asignar valores. 
En R, sin embargo, la forma tradicional de hacerlo es usando una flecha ('<-'). En este libro 
usaremos el signo igual para asignar valores en ambos lenguajes, pero recuerda que, para R, 
'x=10' y 'x<-10' son lo mismo.

[^2]: Python empieza a contar desde cero, por eso funciona de forma diferente a R. Si quieres 
aprender más al respecto, echa un vistazo a [www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html)

[^3]:Las nuevas versiones de Python recuerdan el orden en que se insertan los elementos en un 
diccionario. Sin embargo, para el propósito de esta introducción, puedes asumir que no nos 
importa el orden de los elementos en un diccionario.︎

